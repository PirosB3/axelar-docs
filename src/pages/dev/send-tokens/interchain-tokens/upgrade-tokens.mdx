# Upgrade existing tokens into Interchain Token(s)

If you already have an ERC-20 token on one or more blockchains, you can turn it into an Interchain Token by deploying [Token Managers](../../reference/glossary/#token-manager). Token Managers can be either [Lock/Release](../../reference/glossary/#lockrelease) or [Mint/Burn](../../reference/glossary/#mintburn). Canonical tokens are registered under the Lock/Release token manager on a local chain and mint/burn on remote chains. They can be deployed to remote chains by anyone and don't depend on a deployer address/salt.

To clarify this powerful system, we'll look at two processes for turning existing tokens into Interchain Tokens.

## Canonical Tokens (Simple wrappers)
Suppose you have an ERC-20 token on a single chain, and you'd like a wrapped & bridgeable version to be available on other chains. You can register your ERC-20 as a [Canonical Token](../../reference/glossary/#canonical) with the [Interchain Token Service](https://github.com/axelarnetwork/interchain-token-service/blob/main/contracts/interchain-token-service/InterchainTokenService.sol) using the Factory contract. Each token can only be registered a single time as a canonical chain.

Want to try this out? [Use Remix to create your own ERC-20](https://remix.ethereum.org/axelarnetwork/axelar-docs/blob/main/public/samples/interchain-token-simple.sol) and register your token on the [Interchain Token Portal](https://testnet.interchain.axelar.dev).

You can also do this directly via the Interchain Token Service smart contract. Follow these steps to register your token as a canonical token:

1. First, register your token as a canonical token using the [`registerCanonicalInterchainToken`](https://github.com/axelarnetwork/interchain-token-service/blob/0a00533f19197a285d6bddc8ec0c2e908094ebfe/contracts/InterchainTokenFactory.sol#L238) method on the Interchain Token Factory. This will deploy a [Lock/Release](../../reference/glossary/#lockunlock) - [Token Manager](../..reference/glossary/#token-manager) on the source chain. 

Here is an example of registering a canonical token.

```solidity
/**
 * @notice Registers a canonical token as an interchain token and deploys its token manager.
 * @param tokenAddress The address of the canonical token.
 * @return tokenId The unique identifier of the registered interchain token.
 */
function registerCanonicalInterchainToken(
	address tokenAddress
) external payable returns (bytes32 tokenId);
```
2. Deploy a remote canonical token on your token using the [`deployRemoteCanonicalInterchainToken`](https://github.com/axelarnetwork/interchain-token-service/blob/0a00533f19197a285d6bddc8ec0c2e908094ebfe/contracts/InterchainTokenFactory.sol#L254) method on the Interchain Token Factory for each destination chain. This will create an ERC-20 on each destination chain and [Mint/Burn](../../reference/glossary/#mintburn) - [Token Manager](../../reference/glossary/#token-manager). 

Here is an example of deploying a remote canonical token.

```solidity
/**
 * @notice Deploys a canonical interchain token on a remote chain.
 * @param originalChain The name of the chain where the token originally exists.
 * @param originalTokenAddress The address of the original token on the original chain.
 * @param destinationChain The name of the chain where the token will be deployed.
 * @param gasValue The gas amount to be sent for deployment.
 */
function deployRemoteCanonicalInterchainToken(
    string calldata originalChain,
    address originalTokenAddress,
    string calldata destinationChain,
    uint256 gasValue
) external payable 
```
> If pre-mint is needed, you must make ERC20 approval to the Factory Contract.

When tokens are moved from the origin chain to another chain, the token will be locked on the origin chain and minted on the destination chain. If you moved tokens directly from one non-origin chain to another, the token would be burned on the source chain and minted on the destination chain.

## Link deployed tokens on multiple chains into Interchain Token(s)

If you require custom functionality on multiple chains, you must first deploy your [custom](../../reference/glossary/#custom) token on multiple chains or already have a version of your token on multiple chains.

To turn these deployed tokens into linked Interchain Tokens, register a [Token Manager](../..reference/glossary/#token-manager) for each one. You can optionally have any of these custom tokens extend [`IInterchainTokenStandard`](https://github.com/axelarnetwork/interchain-token-service/blob/v1.0.0-beta.3/contracts/interfaces/IInterchainTokenStandard.soll) to offer [`interchainTransfer`](https://github.com/axelarnetwork/interchain-token-service/blob/0a00533f19197a285d6bddc8ec0c2e908094ebfe/contracts/interfaces/IInterchainTokenStandard.sol#L20) and [`interchainTransferFrom`](https://github.com/axelarnetwork/interchain-token-service/blob/0a00533f19197a285d6bddc8ec0c2e908094ebfe/contracts/interfaces/IInterchainTokenStandard.sol#L37) methods directly on your token.

You could decide to make all of these Token Managers [Mint/Burn](../../reference/glossary/#mintburn), or you could specify at most one (likely your primary/origin chain) to be [Lock/Release](../../reference/glossary/#lockunlock) depending on your needs.

To register a Custom Token via the Interchain Token Service, call the `deployCustomTokenManager` method.

```solidity
/**
 * @notice Used to deploy remote custom TokenManagers.
 * @dev At least the `gasValue` amount of native token must be passed to the function call. `gasValue` exists because this function can be
 * part of a multicall involving multiple functions that could make remote contract calls.
 * @param salt The salt to be used during deployment.
 * @param destinationChain The name of the chain to deploy the TokenManager and standardized token to.
 * @param tokenManagerType The type of TokenManager to be deployed.
 * @param params The params that will be used to initialize the TokenManager.
 * @param gasValue The amount of native tokens to be used to pay for gas for the remote deployment.
 * @return tokenId The tokenId corresponding to the deployed remote TokenManager.
 */
function deployTokenManager(
    bytes32 salt,
    string calldata destinationChain,
    TokenManagerType tokenManagerType,
    bytes calldata params,
    uint256 gasValue
) external payable whenNotPaused returns (bytes32 tokenId)
```

>**Note**: If you want to build your token with the `IInterchainToken` feature yourself, make sure your token implements the [`IInterchainTokenStandard`](https://github.com/axelarnetwork/interchain-token-service/blob/v1.0.0-beta.3/contracts/interfaces/IInterchainTokenStandard.sol) interface so you can offer [`interchainTransfer`](https://github.com/axelarnetwork/interchain-token-service/blob/0a00533f19197a285d6bddc8ec0c2e908094ebfe/contracts/interfaces/IInterchainTokenStandard.sol#L20) and [`interchainTransferFrom`](https://github.com/axelarnetwork/interchain-token-service/blob/0a00533f19197a285d6bddc8ec0c2e908094ebfe/contracts/interfaces/IInterchainTokenStandard.sol#L37) methods directly on your token.

You can try our [sample custom token](https://remix.ethereum.org/axelarnetwork/axelar-docs/blob/main/public/samples/interchain-token-iinterchaintoken.sol) as a starting point. This token self-registers with the Interchain Token Service and can be deployed to multiple chains. 
Once you have designed your token, you can deploy it to multiple chains using a tool such as the [Constant Address Deployer](https://docs.axelar.dev/dev/general-message-passing/solidity-utilities#constant-address-deployer) to give it the same address everywhere.